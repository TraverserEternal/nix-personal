#!/usr/bin/env bash

# NixOS Auto-Configuration Tool
# This script automatically detects hardware and generates NixOS configuration
# files for new systems. It provides a streamlined setup process for deploying
# NixOS on various hardware configurations.

set -euo pipefail

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Logging functions
log_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

# Function to detect CPU type
detect_cpu() {
    log_info "Detecting CPU architecture..."
    if grep -q "GenuineIntel" /proc/cpuinfo; then
        echo "intel"
    elif grep -q "AuthenticAMD" /proc/cpuinfo; then
        echo "amd"
    else
        echo "unknown"
    fi
}

# Function to detect GPU
detect_gpu() {
    log_info "Detecting GPU..."
    if lspci | grep -i nvidia > /dev/null; then
        echo "nvidia"
    elif lspci | grep -i amd > /dev/null && lspci | grep -i vga | grep -i amd > /dev/null; then
        echo "amd"
    else
        echo "intel"
    fi
}

# Function to detect monitors
detect_monitors() {
    log_info "Detecting monitors..."
    xrandr | grep " connected" | awk '{print $1}' || echo "eDP-1"
}

# Function to get disk UUIDs
get_disk_uuids() {
    log_info "Detecting disk UUIDs..."
    lsblk -f | grep -E "^[a-z]" | awk '{print $1 " " $3}' || echo "PLACEHOLDER"
}

# Function to generate hardware.nix
generate_hardware_nix() {
    local cpu_type=$1
    local gpu_type=$2
    local output_dir=$3

    log_info "Generating hardware.nix..."

    cat > "$output_dir/hardware.nix" << EOF
# Hardware Configuration - Auto-generated
# This file was generated by the auto-configuration tool based on detected hardware.
# Review and customize the UUIDs and device paths before using.

{ config, lib, pkgs, modulesPath, ... }:

{
  imports = [ (modulesPath + "/installer/scan/not-detected.nix") ];

  boot.loader.systemd-boot.enable = true;
  boot.loader.efi.canTouchEfiVariables = true;

  boot.initrd.availableKernelModules = [ "xhci_pci" "ahci" "nvme" "usbhid" "usb_storage" "sd_mod" ];
  boot.initrd.kernelModules = [ ];
  boot.kernelModules = [ "kvm-$cpu_type" ];
  boot.extraModulePackages = [ ];

  # LUKS Full Disk Encryption
  boot.initrd.luks.devices = {
    "root" = {
      device = "/dev/disk/by-uuid/PLACEHOLDER";  # Replace with actual root partition UUID
      preLVM = true;
      allowDiscards = true;
    };
  };

  fileSystems."/" = {
    device = "/dev/mapper/vg-root";
    fsType = "ext4";
    options = [ "noatime" "nodiratime" "discard" ];
  };

  fileSystems."/boot" = {
    device = "/dev/disk/by-uuid/PLACEHOLDER";  # Replace with actual boot partition UUID
    fsType = "vfat";
  };

  swapDevices = [
    {
      device = "/dev/mapper/vg-swap";
      encrypted = {
        enable = true;
        label = "swap";
        blkDev = "/dev/disk/by-uuid/PLACEHOLDER";  # Replace with actual swap partition UUID
      };
    }
  ];

  powerManagement.cpuFreqGovernor = lib.mkDefault "ondemand";

  # Hardware-specific configurations
  hardware.graphics = {
    enable = true;
    enable32Bit = true;
EOF

    # Add GPU-specific configuration
    case $gpu_type in
        nvidia)
            cat >> "$output_dir/hardware.nix" << EOF
    # NVIDIA GPU detected
    hardware.nvidia = {
      modesetting.enable = true;
      open = false;
      nvidiaSettings = true;
    };
EOF
            ;;
        amd)
            cat >> "$output_dir/hardware.nix" << EOF
    # AMD GPU detected
    hardware.amdgpu = {
      initrd.enable = true;
      opencl.enable = true;
    };
EOF
            ;;
        *)
            cat >> "$output_dir/hardware.nix" << EOF
    # Intel integrated graphics
    hardware.intelgpu.driver = "i915";
EOF
            ;;
    esac

    cat >> "$output_dir/hardware.nix" << EOF
  };

  hardware.enableRedistributableFirmware = true;
  hardware.enableAllFirmware = true;

  hardware.cpu.${cpu_type}.updateMicrocode = lib.mkDefault config.hardware.enableRedistributableFirmware;
}
EOF
}

# Function to generate configuration.nix template
generate_configuration_nix() {
    local output_dir=$1

    log_info "Generating configuration.nix template..."

    cat > "$output_dir/configuration.nix" << 'EOF'
# NixOS Configuration Template - Auto-generated
# This is a basic template. Customize networking, users, and services as needed.

{ config, lib, pkgs, username ? "user", hostname ? "nixos", ... }:

{
  imports = [ ./hardware.nix ];

  networking.hostName = hostname;
  networking.networkmanager.enable = true;

  time.timeZone = "UTC";

  i18n.defaultLocale = "en_US.UTF-8";

  services.xserver.enable = true;
  services.xserver.displayManager.lightdm.enable = true;
  services.xserver.displayManager.defaultSession = "hyprland";

  programs.hyprland.enable = true;

  users.users.${username} = {
    isNormalUser = true;
    extraGroups = [ "wheel" "networkmanager" ];
    packages = with pkgs; [
      vim
      git
      curl
    ];
  };

  nix.settings.experimental-features = [ "nix-command" "flakes" ];
  nixpkgs.config.allowUnfree = true;

  environment.systemPackages = with pkgs; [
    vim
    git
    curl
    htop
  ];

  services.openssh.enable = true;

  system.stateVersion = "24.05";
}
EOF
}

# Function to generate home.nix template
generate_home_nix() {
    local output_dir=$1

    log_info "Generating home.nix template..."

    cat > "$output_dir/home.nix" << 'EOF'
# Home Manager Configuration Template - Auto-generated

{ config, lib, pkgs, username ? "user", hostname ? "nixos", ... }:

{
  home.stateVersion = "24.05";

  home.username = username;
  home.homeDirectory = "/home/${username}";

  programs.home-manager.enable = true;

  programs.bash = {
    enable = true;
    shellAliases = {
      ll = "ls -alF";
      la = "ls -A";
      l = "ls -CF";
    };
  };

  programs.git = {
    enable = true;
    userName = "User";
    userEmail = "user@example.com";
  };

  home.packages = with pkgs; [
    vim
    git
    curl
    firefox
  ];

  wayland.windowManager.hyprland = {
    enable = true;
    settings = {
      "$mainMod" = "SUPER";
      bind = [
        "$mainMod, Q, exec, foot"
        "$mainMod, C, killactive,"
        "$mainMod, M, exit,"
      ];
    };
  };
}
EOF
}

# Main function
main() {
    local output_dir="${1:-./hosts/auto-generated}"

    log_info "Starting NixOS auto-configuration..."
    log_warn "This tool generates basic configurations. Manual review and customization required!"

    # Check if running as root or with sudo
    if [[ $EUID -eq 0 ]]; then
        log_warn "Running as root. Some detection may not work properly."
    fi

    # Detect hardware
    cpu_type=$(detect_cpu)
    gpu_type=$(detect_gpu)
    monitors=$(detect_monitors)
    disks=$(get_disk_uuids)

    log_info "Detected CPU: $cpu_type"
    log_info "Detected GPU: $gpu_type"
    log_info "Detected monitors: $monitors"
    log_info "Detected disks: $disks"

    # Create output directory
    mkdir -p "$output_dir"
    log_info "Output directory: $output_dir"

    # Generate configuration files
    generate_hardware_nix "$cpu_type" "$gpu_type" "$output_dir"
    generate_configuration_nix "$output_dir"
    generate_home_nix "$output_dir"

    log_success "Configuration files generated successfully!"
    log_info "Next steps:"
    echo "  1. Review and edit the generated files"
    echo "  2. Replace PLACEHOLDER UUIDs with actual partition UUIDs"
    echo "  3. Test with: nixos-rebuild build --flake .#$hostname"
    echo "  4. Install with: nixos-rebuild switch --flake .#$hostname"
}

# Run main function with all arguments
main "$@"
