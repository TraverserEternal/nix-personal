#!/usr/bin/env bash

# NixOS Auto-Configuration Tool
# This script automatically detects hardware and generates NixOS configuration
# files for new systems. It provides a streamlined setup process for deploying
# NixOS on various hardware configurations.

set -euo pipefail

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Logging functions
log_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

# Function to detect CPU type
detect_cpu() {
    log_info "Detecting CPU architecture..."
    if grep -q "GenuineIntel" /proc/cpuinfo; then
        echo "intel"
    elif grep -q "AuthenticAMD" /proc/cpuinfo; then
        echo "amd"
    else
        echo "unknown"
    fi
}

# Function to detect GPU
detect_gpu() {
    log_info "Detecting GPU..."
    if lspci 2>/dev/null | grep -i nvidia > /dev/null; then
        echo "nvidia"
    elif lspci 2>/dev/null | grep -i amd > /dev/null && lspci 2>/dev/null | grep -i vga | grep -i amd > /dev/null; then
        echo "amd"
    else
        echo "intel"
    fi
}

# Function to detect monitors
detect_monitors() {
    log_info "Detecting monitors..."
    xrandr 2>/dev/null | grep " connected" | awk '{print $1}' || echo "eDP-1"
}

# Function to detect partition UUIDs
detect_partition_uuids() {
    log_info "Detecting partition UUIDs..."

    # Get all partitions with their UUIDs and types
    local partitions
    partitions=$(lsblk -f -o NAME,UUID,FSTYPE 2>/dev/null | grep -E "^[a-zA-Z0-9-]+") || {
        log_warn "Could not detect partitions - lsblk failed"
        echo "boot_uuid=PLACEHOLDER root_uuid=PLACEHOLDER swap_uuid=PLACEHOLDER"
        return
    }

    # Initialize UUID variables
    local boot_uuid="" root_uuid="" swap_uuid=""

    # Parse partitions to find specific types
    while IFS= read -r line; do
        local name uuid fstype
        name=$(echo "$line" | awk '{print $1}')
        uuid=$(echo "$line" | awk '{print $2}')
        fstype=$(echo "$line" | awk '{print $3}')

        case $fstype in
            vfat)
                if [ -z "$boot_uuid" ]; then
                    boot_uuid="$uuid"
                    log_info "Detected EFI boot partition: $name (UUID: $uuid)"
                fi
                ;;
            crypto_LUKS)
                if [ -z "$root_uuid" ]; then
                    root_uuid="$uuid"
                    log_info "Detected LUKS root partition: $name (UUID: $uuid)"
                elif [ -z "$swap_uuid" ]; then
                    swap_uuid="$uuid"
                    log_info "Detected LUKS swap partition: $name (UUID: $uuid)"
                fi
                ;;
            swap)
                if [ -z "$swap_uuid" ]; then
                    swap_uuid="$uuid"
                    log_info "Detected swap partition: $name (UUID: $uuid)"
                fi
                ;;
        esac
    done <<< "$partitions"

    # Set defaults if not found
    if [ -z "$boot_uuid" ]; then
        log_warn "EFI boot partition not found - using PLACEHOLDER"
        boot_uuid="PLACEHOLDER"
    fi

    if [ -z "$root_uuid" ]; then
        log_warn "LUKS root partition not found - using PLACEHOLDER"
        root_uuid="PLACEHOLDER"
    fi

    if [ -z "$swap_uuid" ]; then
        log_warn "Swap partition not found - using PLACEHOLDER"
        swap_uuid="PLACEHOLDER"
    fi

    # Return the UUIDs
    echo "boot_uuid=$boot_uuid root_uuid=$root_uuid swap_uuid=$swap_uuid"
}

# Function to generate hardware.nix
generate_hardware_nix() {
    local cpu_type=$1
    local gpu_type=$2
    local boot_uuid=$3
    local root_uuid=$4
    local swap_uuid=$5
    local output_dir=$6

    log_info "Generating hardware.nix..."

    cat > "$output_dir/hardware.nix" << EOF
# Hardware Configuration - Auto-generated
# This file was generated by the auto-configuration tool based on detected hardware.
# Review and customize the UUIDs and device paths before using.

{ config, lib, pkgs, modulesPath, ... }:

{
  imports = [ (modulesPath + "/installer/scan/not-detected.nix") ];

  boot.loader.systemd-boot.enable = true;
  boot.loader.efi.canTouchEfiVariables = true;

  boot.initrd.availableKernelModules = [ "xhci_pci" "ahci" "nvme" "usbhid" "usb_storage" "sd_mod" ];
  boot.initrd.kernelModules = [ ];
  boot.kernelModules = [ "kvm-$cpu_type" ];
  boot.extraModulePackages = [ ];

  # LUKS Full Disk Encryption
  boot.initrd.luks.devices = {
    "root" = {
      device = "/dev/disk/by-uuid/$root_uuid";
      preLVM = true;
      allowDiscards = true;
    };
  };

  fileSystems."/" = {
    device = "/dev/mapper/vg-root";
    fsType = "ext4";
    options = [ "noatime" "nodiratime" "discard" ];
  };

  fileSystems."/boot" = {
    device = "/dev/disk/by-uuid/$boot_uuid";
    fsType = "vfat";
  };

  swapDevices = [
    {
      device = "/dev/mapper/vg-swap";
      encrypted = {
        enable = true;
        label = "swap";
        blkDev = "/dev/disk/by-uuid/$swap_uuid";
      };
    }
  ];

  powerManagement.cpuFreqGovernor = lib.mkDefault "ondemand";

  # Hardware-specific configurations
  hardware.graphics = {
    enable = true;
    enable32Bit = true;
EOF

    # Add GPU-specific configuration
    case $gpu_type in
        nvidia)
            cat >> "$output_dir/hardware.nix" << EOF
    # NVIDIA GPU detected
    hardware.nvidia = {
      modesetting.enable = true;
      open = false;
      nvidiaSettings = true;
    };
EOF
            ;;
        amd)
            cat >> "$output_dir/hardware.nix" << EOF
    # AMD GPU detected
    hardware.amdgpu = {
      initrd.enable = true;
      opencl.enable = true;
    };
EOF
            ;;
        *)
            cat >> "$output_dir/hardware.nix" << EOF
    # Intel integrated graphics
    hardware.intelgpu.driver = "i915";
EOF
            ;;
    esac

    cat >> "$output_dir/hardware.nix" << EOF
  };

  hardware.enableRedistributableFirmware = true;
  hardware.enableAllFirmware = true;

  hardware.cpu.${cpu_type}.updateMicrocode = lib.mkDefault config.hardware.enableRedistributableFirmware;
}
EOF
}

# Function to generate configuration.nix template
generate_configuration_nix() {
    local output_dir=$1

    log_info "Generating configuration.nix template..."

    cat > "$output_dir/configuration.nix" << 'EOF'
# NixOS Configuration Template - Auto-generated
# This is a basic template. Customize networking, users, and services as needed.

{ config, lib, pkgs, username ? "user", hostname ? "nixos", ... }:

{
  imports = [ ./hardware.nix ];

  networking.hostName = hostname;
  networking.networkmanager.enable = true;

  time.timeZone = "UTC";

  i18n.defaultLocale = "en_US.UTF-8";

  services.xserver.enable = true;
  services.xserver.displayManager.lightdm.enable = true;
  services.xserver.displayManager.defaultSession = "hyprland";

  programs.hyprland.enable = true;

  users.users.${username} = {
    isNormalUser = true;
    extraGroups = [ "wheel" "networkmanager" ];
    packages = with pkgs; [
      vim
      git
      curl
    ];
  };

  nix.settings.experimental-features = [ "nix-command" "flakes" ];
  nixpkgs.config.allowUnfree = true;

  environment.systemPackages = with pkgs; [
    vim
    git
    curl
    htop
  ];

  services.openssh.enable = true;

  system.stateVersion = "24.05";
}
EOF
}

# Function to generate home.nix template
generate_home_nix() {
    local output_dir=$1

    log_info "Generating home.nix template..."

    cat > "$output_dir/home.nix" << 'EOF'
# Home Manager Configuration Template - Auto-generated

{ config, lib, pkgs, username ? "user", hostname ? "nixos", ... }:

{
  home.stateVersion = "24.05";

  home.username = username;
  home.homeDirectory = "/home/${username}";

  programs.home-manager.enable = true;

  programs.bash = {
    enable = true;
    shellAliases = {
      ll = "ls -alF";
      la = "ls -A";
      l = "ls -CF";
    };
  };

  programs.git = {
    enable = true;
    userName = "User";
    userEmail = "user@example.com";
  };

  home.packages = with pkgs; [
    vim
    git
    curl
    firefox
  ];

  wayland.windowManager.hyprland = {
    enable = true;
    settings = {
      "$mainMod" = "SUPER";
      bind = [
        "$mainMod, Q, exec, foot"
        "$mainMod, C, killactive,"
        "$mainMod, M, exit,"
      ];
    };
  };
}
EOF
}

# Main function
main() {
    local output_dir="${1:-./modules/generated}"

    log_info "Starting NixOS auto-configuration..."
    log_warn "This tool generates basic configurations. Manual review and customization required!"

    # Check if running as root or with sudo
    if [[ $EUID -eq 0 ]]; then
        log_warn "Running as root. Some detection may not work properly."
    fi

    # Detect hardware
    cpu_type=$(detect_cpu)
    gpu_type=$(detect_gpu)
    monitors=$(detect_monitors)
    uuid_output=$(detect_partition_uuids)

    # Parse UUIDs from output
    boot_uuid=$(echo "$uuid_output" | sed 's/.*boot_uuid=\([^ ]*\).*/\1/')
    root_uuid=$(echo "$uuid_output" | sed 's/.*root_uuid=\([^ ]*\).*/\1/')
    swap_uuid=$(echo "$uuid_output" | sed 's/.*swap_uuid=\([^ ]*\).*/\1/')

    log_info "Detected CPU: $cpu_type"
    log_info "Detected GPU: $gpu_type"
    log_info "Detected monitors: $monitors"
    log_info "Detected UUIDs - Boot: $boot_uuid, Root: $root_uuid, Swap: $swap_uuid"

    # Create output directory
    mkdir -p "$output_dir"
    log_info "Output directory: $output_dir"

    # Generate configuration files
    generate_hardware_nix "$cpu_type" "$gpu_type" "$boot_uuid" "$root_uuid" "$swap_uuid" "$output_dir"
    generate_configuration_nix "$output_dir"
    generate_home_nix "$output_dir"

    log_success "Configuration files generated successfully!"
    log_info "Next steps:"
    echo "  1. Review the generated files in $output_dir/"
    echo "  2. If UUIDs show PLACEHOLDER, check partition detection or edit manually"
    echo "  3. Test with: sudo nixos-rebuild build --flake .#default"
    echo "  4. Install with: sudo nixos-rebuild switch --flake .#default"
}

# Run main function with all arguments
main "$@"
